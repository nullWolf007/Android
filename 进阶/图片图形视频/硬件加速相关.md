[TOC]
- <!-- TOC -->
- [ 硬件加速相关](#硬件加速相关)
  - [ 参考链接](#参考链接)
  - [ 一、硬件加速指南](#一硬件加速指南)
    - [ 1.1 说明](#11-说明)
    - [ 1.2 控制硬件加速](#12-控制硬件加速)
      - [ 1.2.1 应用级别](#121-应用级别)
      - [ 1.2.2 Activity级别](#122-Activity级别)
      - [ 1.2.3 窗口级别](#123-窗口级别)
      - [ 1.2.4 视图级别](#124-视图级别)
    - [ 1.3 确定视图是否经过硬件加速](#13-确定视图是否经过硬件加速)
      - [ 1.3.1 View](#131-View)
      - [ 1.3.2 Canvas](#132-Canvas)
      - [ 1.3.3 说明](#133-说明)
    - [ 1.4 绘制模型](#14-绘制模型)
      - [ 1.4.1 基于软件的绘制模型](#141-基于软件的绘制模型)
      - [ 1.4.2 硬件加速绘制模型](#142-硬件加速绘制模型)
    - [ 1.5 不受支持的绘制操作](#15-不受支持的绘制操作)
    - [ 1.6 视图层](#16-视图层)
      - [ 1.6.1 视图的绘制缓存](#161-视图的绘制缓存)
      - [ 1.6.2 层类型选择](#162-层类型选择)
      - [ 1.6.3 视图层和动画](#163-视图层和动画)
    - [ 1.7 提示和技巧](#17-提示和技巧)
      - [ 1.7.1 减少应用中的试图数量](#171-减少应用中的试图数量)
      - [ 1.7.2 避免过度绘制](#172-避免过度绘制)
      - [ 1.7.3 请勿在绘制方法中创建渲染对象](#173-请勿在绘制方法中创建渲染对象)
      - [ 1.7.4 请勿过于频繁的修改形状](#174-请勿过于频繁的修改形状)
      - [ 1.7.5 请勿过于频繁地修改位图](#175-请勿过于频繁地修改位图)
      - [ 1.7.6 谨慎使用Alpha](#176-谨慎使用Alpha)
  <!-- /TOC -->
# 硬件加速相关

### 参考链接

* [Android官网-硬件加速](https://developer.android.com/guide/topics/graphics/hardware-accel#unsupported)

## 一、硬件加速指南

### 1.1 说明

* 从 Android 3.0（API 级别 11）开始，Android 2D 渲染管道支持硬件加速，也就是说，在 `View` 的画布上执行的所有绘制操作都会使用 GPU。启用硬件加速需要更多资源，因此应用会占用更多内存。如果您的目标 API 级别为 14 及更高级别，则硬件加速默认处于启用状态，但也可以明确启用该功能。如果您的应用仅使用标准视图和 `Drawable`，则全局启用硬件加速不会造成任何不良绘制效果。不过，并非所有 2D 绘制操作都支持硬件加速，因此启用硬件加速可能会影响您的部分自定义视图或绘制调用。具体问题通常以不可见的元素、异常或错误渲染的像素显现。

### 1.2 控制硬件加速

#### 1.2.1 应用级别

* 在Android清单文件中，将以下属性添加到`<application>`标记中，为整个应用启用硬件加速

```xml
	<application android:hardwareAccelerated="true" ...>
```

#### 1.2.2 Activity级别

* 如果全局启用硬件加速后，应用无法正常运行，可以针对Activity控制硬件加速。使用`<activity>`元素的`android:hardwareAccelerated`属性

```xml
    <application android:hardwareAccelerated="true">
        <activity ... />
        <activity android:hardwareAccelerated="false" />
    </application>
```

#### 1.2.3 窗口级别

* 如果需要实现更精细的控制，可以使用以下代码为给定窗口启用硬件加速
* 目前不支持窗口级别关闭硬件加速

```java
    getWindow().setFlags(
        WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
        WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
```

#### 1.2.4 视图级别

* 可以使用以下代码在运行时为单个视图停用硬件加速

```java
    myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);
```

```xml
	<EditeText
    	android:layerType="software"       
	/>
```

### 1.3 确定视图是否经过硬件加速

#### 1.3.1 View

```java
View.isHardwareAccelerated();//如果View已附加到硬件加速窗口，则返true
```

#### 1.3.2 Canvas

```java
Canvas.isHardwareAccelerated();//如果Canvas经过硬件加速，则返回true
```

#### 1.3.3 说明

* 如果必须在绘制代码中执行这项检查，请尽可能使用`Canvas.isHardwareAccelerated()`。因为如果某个已附加到硬件加速窗口，则仍可以使用未经过硬件加速的画布进行绘制

### 1.4 绘制模型

* 启用硬件加速后，Android框架会采用新的绘制模型，该模型利用显示列表将应用渲染到屏幕上

#### 1.4.1 基于软件的绘制模型

**两步**

* 对层次结构进行无效化处理
* 绘制层次结构

**说明**

* 每当应用需要更新界面的一部分时，就会对内容已发生更改的所有视图调用`invalidate()`（或其变体之一）。无效化消息会一致传播到视图层次结构上层，以计算需要重新绘制的屏幕区域（脏区域）。然后，Android系统会绘制层次结构中与脏数据交互的所有视图。
* Android视图会在其属性（例如TextView中的背景颜色或文本）发生更改时自动调用`invalidate()`

**缺点**

* 每次绘制时该模型需要执行大量代码。例如，如果应用对某个按钮调用`invalidate()`且按钮位于另一个视图上方，那么即使该视图未发生更改，Android系统仍会重新绘制该视图
* 该绘制模型会隐藏应用中的错误，由于Android系统会在视图与脏区域交互时重新绘制视图，因此系统可能会重新绘制内容发生更改的视图，即使未对其调用`invalidate()`也是如此。如果发生这种情况，可能需要依赖其他经过无效化处理的视图才能获得正确的行为，每次修改应用时，此行为都可能会发生更改。因此每次会影响视图绘代码的数据或状态后，都要对自定义视图调用`invalidate()`

#### 1.4.2 硬件加速绘制模型

* Android系统仍会使用`invalidate()`和`draw()`请求屏幕更新和渲染视图，但会采用其他方式处理实际绘制过程。Android系统不会立即执行绘制命令，而是将这些命令记录在显示列表中，这些列表中包含视图层次机构绘制代码的输出。另一项优化是，Android系统只需要记录和更新被`invalidate()`调用标记为脏视图的视图的显示列表。只需重新发出之前记录的显示列表，即可重新绘制未经过无效化处理的视图

**三个阶段**

* 对层次结构进行无效化处理
* 记录并更新显示列表
* 绘制显示列表

**说明**

* 使用此模型时，无法依赖于脏数据交互的视图来执行其`draw()`方法。要确保Android系统会记录视图的显示列表，必须调用`invalidate()`。如果忘记执行此操作，则视图在发生更改后看起来仍然没有变化
* 使用显示列表还有助于改进动画性能，因为设置特定属性（例如Alpha或旋转）不需要对目标视图进行无效化处理（该操作是自动完成的）。这项优化还适用于具有显示列表的视图（如果应用经过硬件加速，则适用于所有视图）

**举例**

* 假设有一个`LinearLayout`，其中包含一个`ListView`（位于`Button`之上）。`LinearLayout`的显示列表如下所示
  * DrawDisplayList(ListView)
  * DrawDisplayList(Button)
* 假设现在要更改`ListView`的不透明度。在对`ListView`调用`setAlpha(0.5f)`后，显示列表现在包含以下内容
  * SaveLayerAlpha(0.5)
  * DrawDisplayList(ListView)
  * Restore
  * DrawDisplayList(Button)
* 系统没有执行`ListView`的复杂绘制代码，而是仅更新了更为简单的`LinearLayout`的显示列表。在未启用硬件加速的应用中，系统会再次执行列表及其父级的绘制代码

### 1.5 不受支持的绘制操作

下表介绍了各种操作在各个 API 级别的支持级别：

|                                       | 第一个支持的 API 级别 |
| ------------------------------------- | --------------------- |
| **Canvas**                            |                       |
| drawBitmapMesh()（颜色数组）          | 18                    |
| drawPicture()                         | 23                    |
| drawPosText()                         | 16                    |
| drawTextOnPath()                      | 16                    |
| drawVertices()                        | ✗                     |
| setDrawFilter()                       | 16                    |
| clipPath()                            | 18                    |
| clipRegion()                          | 18                    |
| clipRect(Region.Op.XOR)               | 18                    |
| clipRect(Region.Op.Difference)        | 18                    |
| clipRect(Region.Op.ReverseDifference) | 18                    |
| clipRect()（通过旋转/透视）           | 18                    |
| **Paint**                             |                       |
| setAntiAlias()（适用于文本）          | 18                    |
| setAntiAlias()（适用于线条）          | 16                    |
| setFilterBitmap()                     | 17                    |
| setLinearText()                       | ✗                     |
| setMaskFilter()                       | ✗                     |
| setPathEffect()（适用于线条）         | 28                    |
| setShadowLayer()（除文本之外）        | 28                    |
| setStrokeCap()（适用于线条）          | 18                    |
| setStrokeCap()（适用于点）            | 19                    |
| setSubpixelText()                     | 28                    |
| **Xfermode**                          |                       |
| PorterDuff.Mode.DARKEN（帧缓冲区）    | 28                    |
| PorterDuff.Mode.LIGHTEN（帧缓冲区）   | 28                    |
| PorterDuff.Mode.OVERLAY（帧缓冲区）   | 28                    |
| **Shader**                            |                       |
| ComposeShader 内的 ComposeShader      | 28                    |
| ComposeShader 内相同类型的着色器      | 28                    |
| ComposeShader 上的本地矩阵            | 18                    |

| 要缩放的绘制操作 | 第一个支持的 API 级别 |
| ---------------- | --------------------- |
| drawText()       | 18                    |
| drawPosText()    | 28                    |
| drawTextOnPath() | 28                    |
| 简单的形状*      | 17                    |
| 复杂的形状*      | 28                    |
| drawPath()       | 28                    |
| 阴影层           | 28                    |

### 1.6 视图层

* 视图能够通过以下两种方式渲染到屏幕外缓冲区：使用视图的绘制缓存或使用`Canvas.setLayer()`

#### 1.6.1 视图的绘制缓存

**View.setLayerType()**

**三种层类型**

* LAYER_TYPE_NONE：视图正常渲染，不受屏幕外缓冲区支持。这是默认行为
* LAYER_TYPE_HARDWARE：如果应用经过硬件加速，视图在硬件中渲染为硬件纹理。如果应用未经过硬件加速，此层类型的行为方式与LAYER_TYPE_SOFTWARE相同
* LAYER_TYPE_SOFTWARE：视图在软件中渲染为位图

#### 1.6.2 层类型选择

* 性能：使用硬件层类型可将视图渲染为硬件纹理。将视图渲染为层后，在该视图调用`invalidate()`之前，无需执行其绘制代码。然后，可将Alpha动画等部分动画直接应用到层，GPU可非常高效地完成此操作
* 视觉效果：使用硬件层或软件层类型和`Paint`可将特殊视觉处理应用到视图。例如，可以使用`ColorMatrixColorFilter`绘制黑白视图
* 兼容性：使用软件层类型可强制在软件中渲染视图。如果经过硬件加速的视图（例如，如果整个应用都经过硬件加速）遇到渲染问题，采用这种方法可轻松解决硬件渲染管道的局限性

#### 1.6.3 视图层和动画

* 如果应用经过硬件加速，硬件层能够提供更快且更顺畅的动画。在为需要发出大量绘制操作的复杂视图添加动画效果时，以 60 帧/秒的速度运行动画并非总能实现。使用硬件层将视图渲染为硬件纹理可在一定程度上解决此问题。然后，硬件纹理可用于为视图添加动画效果，这样视图在动画效果添加过程中无需不断自行重新绘制。除非您更改视图的属性（这会调用 `invalidate()`），或者手动调用 `invalidate()`，否则系统不会重新绘制视图。如果您在应用中运行动画，但没有获得想要的顺畅动画，请考虑对添加动画效果之后的视图启用硬件层。

### 1.7 提示和技巧

#### 1.7.1 减少应用中的试图数量

* 系统需要绘制的视图越多，运行速度越慢。这也适用于软件渲染管道。减少视图是优化界面最简单的方法之一

#### 1.7.2 避免过度绘制

* 请勿在上方绘制过多层，如果你需要在上方绘制很多层，请考虑对层进行合并。对于目前的硬件来说，绘制的层数最好不超过屏幕上每帧像素数的2.5倍（透明像素，以位图计数）

#### 1.7.3 请勿在绘制方法中创建渲染对象

* 常见的错误就是，每次调用渲染方法时都创建新的`Paint`或`Path`。这种垃圾回收会更频繁的进行，同时还会绕过硬件管道中的缓存和优化

#### 1.7.4 请勿过于频繁的修改形状

#### 1.7.5 请勿过于频繁地修改位图

#### 1.7.6 谨慎使用Alpha









