# 内存泄露相关

### 参考链接

* [**Android内存泄漏检测和定位**](https://www.jianshu.com/p/1972a6d1f0fc)

* [**Android常见内存泄漏分析**](https://www.jianshu.com/p/52ac1ded7618)
* [**一篇技术好文之Android性能优化内存泄漏无处可藏（图文）**](https://www.jianshu.com/p/86a6d5cd3b05)

## 一、前言

### 1.1 内存泄漏含义

* 内存泄漏就是分配的内存空间没有及时回收导致的。可使用的内存变少，应用变卡，最后内存溢出后应用就会崩溃。

## 二、内存泄露检测

### 2.1 内存泄露检测工具

#### 2.1.1 Profiler

* Android Studio自带的，可以直观的看到CPU、内存、网络的变化，但是有时候简单看是看不出内存泄露的，需要借助别的工具去帮我们分析

#### 2.1.2 LeakCanary

* 常用的内存泄露检测的工具，是一个三方，使用简单。

### 2.2 使用Profiler来查看内存泄漏

* 查看详情请点击[Profiler的使用教程](https://github.com/nullWolf007/Android/blob/master/%E8%BF%9B%E9%98%B6/AS%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7/Profiler%E7%9A%84%E4%BD%BF%E7%94%A8.md)

### 2.3 使用LeakCanary

* 查看使用情况的话，直接查看官网即可
* 查看请点击[LeakCanary](https://github.com/square/leakcanary)

## 三、常见的内存泄漏及解决方法

### 3.1 内存泄漏的分类和影响

* **分类**：常发性内存泄漏，偶发性内存泄漏，一次性内存泄漏，隐式内存泄漏
* **危害**：内存泄露造成的影响其实是内存泄漏的堆积，这将会消耗系统所有的内存。所以一个内存泄露的危害并不大，因为不会堆积，而隐式内存泄漏危害性则非常大，因为较之常发性和偶发性内存泄露它更难被检测到。

### 3.2 常见的内存泄漏及解决办法

#### 3.2.1 单例造成的内存泄漏

**第一种情况**

```java
public class LoginActivity extends Activity {
    public static LoginActivity instance;
     @Override
    protected void onCreate(Bundle savedInstanceState) {
        ……
        instance = this;
    }
}
```

在其他地方引用LoginActivity.instance会造成检测如下

![单例内存泄露1](https://github.com/nullWolf007/images/raw/master/android/%E8%BF%9B%E9%98%B6/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/%E5%8D%95%E4%BE%8B%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F1.png)



这种情况我们可以通过使用弱引用的方法来优化，修改如下

```java
public class LoginActivity extends Activity {
    public static WeakReference<LoginActivity> instance;
     @Override
    protected void onCreate(Bundle savedInstanceState) {
        ……
        instance = new WeakReference<LoginActivity>(this);
    }
}
```

**第二种情况**

```java
public class AppManager {
    private static AppManager instance;
    private Context context;
    private AppManager(Context context) {
        this.context = context;
    }
    public static AppManager getInstance(Context context) {
        if (instance == null) {
            instance = new AppManager(context);
        }
    return instance;
}
```

检测结果如下

![单例内存泄漏2](https://github.com/nullWolf007/images/raw/master/android/%E8%BF%9B%E9%98%B6/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/%E5%8D%95%E4%BE%8B%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B22.png)

解决办法，使用Application的context替代Activity的context,修改后的代码如下：

```java
public class LoginManager {
  private static LoginManager mInstance;
  private Context mContext;
  private LoginManager(Context context) {
    this.mContext = context.getApplicationContext();
  }
  public static LoginManager getInstance(Context context) {
    if (mInstance == null) {
      synchronized (LoginManager.class) {
        if (mInstance == null) {
          mInstance = new LoginManager(context);
        }
      }
    }
    return mInstance;
  }
  public void dealData() {
  }
}
```

#### 3.2.2 接口实现引用造成的内存泄漏

```java
public class MyApplication extends LitePalApplication{
    ……
     UnReadMsgListener unReadMsgListener;
     public void setUnReadMsgListener(UnReadMsgListener unReadMsgListener){
          this.unReadMsgListener = unReadMsgListener;//在其他页面进行接口实现
     } 
     ……
}
```

