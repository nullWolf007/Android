

[TOC]

# 类与继承

### 参考链接

* [Kotlin中文站](https://www.kotlincn.net/docs/reference/basic-types.html)

### 1 类

* 语法

  ```kotlin
  class Invoice { /*……*/ }
  ```

* 如果一个类没有类体，可以省略花括号

  ```kotlin
  class Empty
  ```

### 1 构造函数

* 小于等于一个的**主构造函数**和大于等于零个的**次构造函数**，主构造函数是类头的一部分，跟在类名的后面。如果没有显式创建主构造函数和次构造函数，系统会自动生成无参的主构造函数。

  ```kotlin
  class Person constructor(name:String){
  }
  ```

*  如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 *constructor* 关键字。 

  ```kotlin
  class Person(name:String){
  }
  ```

*  主构造函数不能包含任何的代码。初始化的代码可以放到以 *init* 关键字作为前缀的**初始化块（initializer blocks）**中。  实例初始化期间，初始化块按照它们出现在类体中的顺序执行 ，与属性初始化器交织在一起  。如下代码所示，按顺序输出

  ```kotlin
  class InitOrderDemo(name: String) {
      val firstProperty = "First property: $name".also(::println)
  
      init {
          println("First initializer block that prints ${name}")
      }
  
      val secondProperty = "Second property: ${name.length}".also(::println)
  
      init {
          println("Second initializer block that prints ${name.length}")
      }
  }
  ```

*  如果构造函数有注解或可见性修饰符，这个 *constructor* 关键字是必需的，并且这些修饰符在它前面： 

  ```kotlin
  class Customer public @Inject constructor(name: String) { /*……*/ }
  ```

### 3 次构造函数

* 次构造函数在类内定义，以 *constructor* 开头

  ```kotlin
  fun main() {
      var user = User("木木", 18)
      //报错，和Java类似，次构造函数会取代无参的主构造函数，如需无参的构造函数需要显示声明
      //class User()
      user.printName()
  }
  
  class User {
      private var username: String = "名字"
      private var age: Int = 0
  
      //有显示无参的主构造函数的情况下 次构造函数代码如下注释所示
      //constructor(username: String, age: Int) : this() {
      constructor(username: String, age: Int){
          this.username = username
          this.age = age
      }
  
      fun printName() {
          println("${this.username}")
      }
  }
  ```

*  如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 *this* 关键字即可： 

  ```kotlin
  class User(private var username: String) {
      private var age: Int = 0
  
      constructor(username: String, age: Int) : this(username) {
          this.username = username
          this.age = age
      }
  }
  ```

*  请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此**所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行**。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块： 

  ```kotlin
  fun main() {
      val test = Test(1)
  }
  
  class Test {
      init {
          println("Init block")
      }
      constructor(i: Int) {
          println("Constructor")
      }
  }
  //输出
  //Init block
  //Constructor
  ```

*  如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数，不声明的话会生成公有的无参的构造函数

  ```kotlin
  class Test private constructor(){
  }
  ```

### 4 创建类的实例

* kotlin中没有new关键字，所以创建类的实例，如下所示

  ```kotlin
  val invoice = Invoice()//无参的构造方法
  val customer1 = Customer("Joe Smith")//有参的构造方法
  val customer2:Customer = Customer("Joe Smith")
  ```

### 5 类成员

* 构造函数
* 函数
* 属性
* 嵌套类与内部类
* 对象声明

###  继承

*  在 Kotlin 中所有类都有一个共同的超类 `Any`，这对于没有超类型声明的类是默认超类： 

  ```kotlin
  class Test
  ```

*  显式声明一个类的超类，在类头上把超类类型放在冒号后面。kotlin中类的参数默认为final，如果该类需要被继承的话，需要使用open关键字

   ```kotlin
   open class Base(v:Int)
   class Test(v:Int):Base(v)
   ```

*  如果派生类有一个主构造函数，其基类可以（并且必须） 用派生类主构造函数的参数就地初始化。

*  如果派生类没有主构造函数，那么每个次构造函数必须使用 *super* 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：

   ```kotlin
   open class Base(v: Int) {
   }
   
   class Test : Base {
       constructor(v: Int) : super(v) {
   
       }
   }
   ```

### 7 覆盖方法

*  Kotlin 对于可覆盖的成员（我们称之为*开放*）以及覆盖后的成员需要显式修饰符。如果方法需要被覆盖的话，也是需要open关键字的，默认为final，不能被覆盖

  ```kotlin
  open class Shape {
      open fun draw() { /*……*/
      }
  
      fun fill() { /*……*/
      }
  }
  
  class Circle() : Shape() {
      override fun draw() { /*……*/
      }
  }
  ```

*  标记为 *override* 的成员本身是开放的， 如果你想要它禁止被再次覆盖的话，需要手动添加final关键字。这样该方法就不会被再次覆盖，如下所示

  ```kotlin
  final override fun draw()
  ```

### 8 覆盖属性

* 

